

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.4 Error Detection &mdash; Computer Networks: A Systems Approach Version 6.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../static/bridge.ico"/>
  
  
  

  
  <script type="text/javascript" src="../static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
        <script type="text/javascript" src="../static/jquery.js"></script>
        <script type="text/javascript" src="../static/underscore.js"></script>
        <script type="text/javascript" src="../static/doctools.js"></script>
        <script type="text/javascript" src="../static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../static/css/rtd_theme_mods.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2.5 Reliable Transmission" href="reliable.html" />
    <link rel="prev" title="2.3 Framing" href="framing.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Computer Networks: A Systems Approach
          

          
          </a>

          
            
            
              <div class="version">
                Version 6.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../foundation.html">Chapter 1:  Foundation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../direct.html">Chapter 2:  Direct Links</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="problem.html">Problem: Connecting to a Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="perspective.html">2.1 Technology Landscape</a></li>
<li class="toctree-l2"><a class="reference internal" href="encoding.html">2.2 Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="framing.html">2.3 Framing</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.4 Error Detection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#internet-checksum-algorithm">Internet Checksum Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cyclic-redundancy-check">Cyclic Redundancy Check</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="reliable.html">2.5 Reliable Transmission</a></li>
<li class="toctree-l2"><a class="reference internal" href="ethernet.html">2.6 Multi-Access Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="wireless.html">2.7 Wireless Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="access.html">2.8 Access Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="trend.html">Perspective: Race to the Edge</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../README.html">About This Book</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Computer Networks: A Systems Approach</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../direct.html">Chapter 2:  Direct Links</a> &raquo;</li>
        
      <li>2.4 Error Detection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/direct/error.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="error-detection">
<h1>2.4 Error Detection<a class="headerlink" href="#error-detection" title="Permalink to this headline">¶</a></h1>
<p>As discussed in Chapter&nbsp;1, bit errors are sometimes introduced into
frames. This happens, for example, because of electrical interference or
thermal noise. Although errors are rare, especially on optical links,
some mechanism is needed to detect these errors so that corrective
action can be taken. Otherwise, the end user is left wondering why the C
program that successfully compiled just a moment ago now suddenly has a
syntax error in it, when all that happened in the interim is that it was
copied across a network file system.</p>
<p>There is a long history of techniques for dealing with bit errors in
computer systems, dating back to at least the 1940s. Hamming and
Reed-Solomon codes are two notable examples that were developed for use
in punch card readers, when storing data on magnetic disks, and in early
core memories. This section describes some of the error detection
techniques most commonly used in networking.</p>
<p>Detecting errors is only one part of the problem. The other part is
correcting errors once detected. Two basic approaches can be taken when
the recipient of a message detects an error. One is to notify the sender
that the message was corrupted so that the sender can retransmit a copy
of the message. If bit errors are rare, then in all probability the
retransmitted copy will be error free. Alternatively, some types of
error detection algorithms allow the recipient to reconstruct the
correct message even after it has been corrupted; such algorithms rely
on <em>error-correcting codes</em>, discussed below.</p>
<p>One of the most common techniques for detecting transmission errors is a
technique known as the <em>cyclic redundancy check</em> (CRC). It is used in
nearly all the link-level protocols discussed in this chapter. This
section outlines the basic CRC algorithm, but before discussing that
approach, we first describe the simpler <em>checksum</em> scheme used by
several Internet protocols.</p>
<p>The basic idea behind any error detection scheme is to add redundant
information to a frame that can be used to determine if errors have been
introduced. In the extreme, we could imagine transmitting two complete
copies of the data. If the two copies are identical at the receiver,
then it is probably the case that both are correct. If they differ, then
an error was introduced into one (or both) of them, and they must be
discarded. This is a rather poor error detection scheme for two reasons.
First, it sends <em>n</em> redundant bits for an <em>n</em>-bit message. Second, many
errors will go undetected—any error that happens to corrupt the same bit
positions in the first and second copies of the message. In general, the
goal of error detecting codes is to provide a high probability of
detecting errors combined with a relatively low number of redundant
bits.</p>
<p>Fortunately, we can do a lot better than this simple scheme. In general,
we can provide quite strong error detection capability while sending
only <em>k</em> redundant bits for an <em>n</em>-bit message, where <em>k</em> is much
smaller than <em>n</em>. On an Ethernet, for example, a frame carrying up to
12,000&nbsp;bits (1500&nbsp;bytes) of data requires only a 32-bit CRC code, or as
it is commonly expressed, uses CRC-32. Such a code will catch the
overwhelming majority of errors, as we will see below.</p>
<p>We say that the extra bits we send are redundant because they add no new
information to the message. Instead, they are derived directly from the
original message using some well-defined algorithm. Both the sender and
the receiver know exactly what that algorithm is. The sender applies the
algorithm to the message to generate the redundant bits. It then
transmits both the message and those few extra bits. When the receiver
applies the same algorithm to the received message, it should (in the
absence of errors) come up with the same result as the sender. It
compares the result with the one sent to it by the sender. If they
match, it can conclude (with high likelihood) that no errors were
introduced in the message during transmission. If they do not match, it
can be sure that either the message or the redundant bits were
corrupted, and it must take appropriate action—that is, discarding the
message or correcting it if that is possible.</p>
<p>One note on the terminology for these extra bits. In general, they are
referred to as <em>error-detecting codes</em>. In specific cases, when the
algorithm to create the code is based on addition, they may be called a
<em>checksum</em>. We will see that the Internet checksum is appropriately
named: It is an error check that uses a summing algorithm.
Unfortunately, the word <em>checksum</em> is often used imprecisely to mean any
form of error-detecting code, including CRCs. This can be confusing, so
we urge you to use the word <em>checksum</em> only to apply to codes that
actually do use addition and to use <em>error-detecting code</em> to refer to
the general class of codes described in this section.</p>
<div class="section" id="internet-checksum-algorithm">
<h2>Internet Checksum Algorithm<a class="headerlink" href="#internet-checksum-algorithm" title="Permalink to this headline">¶</a></h2>
<p>Our first approach to error detection is exemplified by the Internet
checksum. Although it is not used at the link level, it nevertheless
provides the same sort of functionality as CRCs, so we discuss it here.</p>
<p>The idea behind the Internet checksum is very simple—you add up all the
words that are transmitted and then transmit the result of that sum. The
result is the checksum. The receiver performs the same calculation on
the received data and compares the result with the received checksum. If
any transmitted data, including the checksum itself, is corrupted, then
the results will not match, so the receiver knows that an error
occurred.</p>
<p>You can imagine many different variations on the basic idea of a
checksum. The exact scheme used by the Internet protocols works as
follows. Consider the data being checksummed as a sequence of 16-bit
integers. Add them together using 16-bit ones’ complement arithmetic
(explained below) and then take the ones’ complement of the result. That
16-bit number is the checksum.</p>
<p>In ones’ complement arithmetic, a negative integer (-x) is represented
as the complement of x; that is, each bit of x is inverted. When adding
numbers in ones’ complement arithmetic, a carryout from the most
significant bit needs to be added to the result. Consider, for example,
the addition of -5 and -3 in ones’ complement arithmetic on 4-bit
integers: +5 is 0101, so -5 is 1010; +3 is 0011, so -3 is 1100. If we
add 1010 and 1100, ignoring the carry, we get 0110. In ones’ complement
arithmetic, the fact that this operation caused a carry from the most
significant bit causes us to increment the result, giving 0111, which is
the ones’ complement representation of -8 (obtained by inverting the
bits in 1000), as we would expect.</p>
<p>The following routine gives a straightforward implementation of the
Internet’s checksum algorithm. The <code class="docutils literal notranslate"><span class="pre">count</span></code> argument gives the length
of <code class="docutils literal notranslate"><span class="pre">buf</span></code> measured in 16-bit units. The routine assumes that <code class="docutils literal notranslate"><span class="pre">buf</span></code>
has already been padded with 0s to a 16-bit boundary.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u_short</span>
<span class="n">cksum</span><span class="p">(</span><span class="n">u_short</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="nb">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">register</span> <span class="n">u_long</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">sum</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">/*</span> <span class="n">carry</span> <span class="n">occurred</span><span class="p">,</span> <span class="n">so</span> <span class="n">wrap</span> <span class="n">around</span> <span class="o">*/</span>
            <span class="nb">sum</span> <span class="o">&amp;=</span> <span class="mh">0xFFFF</span><span class="p">;</span>
            <span class="nb">sum</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">~</span><span class="p">(</span><span class="nb">sum</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code ensures that the calculation uses ones’ complement arithmetic
rather than the twos’ complement that is used in most machines. Note the
<code class="docutils literal notranslate"><span class="pre">if</span></code> statement inside the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop. If there is a carry into the
top 16&nbsp;bits of <code class="docutils literal notranslate"><span class="pre">sum</span></code>, then we increment <code class="docutils literal notranslate"><span class="pre">sum</span></code> just as in the
previous example.</p>
<p>Compared to our repetition code, this algorithm scores well for using a
small number of redundant bits—only 16 for a message of any length—but
it does not score extremely well for strength of error detection. For
example, a pair of single-bit errors, one of which increments a word and
one of which decrements another word by the same amount, will go
undetected. The reason for using an algorithm like this in spite of its
relatively weak protection against errors (compared to a CRC, for
example) is simple: This algorithm is much easier to implement in
software. Experience has suggested that a checksum of this form was
adequate, but one reason it is adequate is that this checksum is the
last line of defense in an end-to-end protocol. The majority of errors
are picked up by stronger error detection algorithms, such as CRCs, at
the link level.</p>
</div>
<div class="section" id="cyclic-redundancy-check">
<h2>Cyclic Redundancy Check<a class="headerlink" href="#cyclic-redundancy-check" title="Permalink to this headline">¶</a></h2>
<p>It should be clear by now that a major goal in designing error detection
algorithms is to maximize the probability of detecting errors using only
a small number of redundant bits. Cyclic redundancy checks use some
fairly powerful mathematics to achieve this goal. For example, a 32-bit
CRC gives strong protection against common bit errors in messages that
are thousands of bytes long. The theoretical foundation of the cyclic
redundancy check is rooted in a branch of mathematics called <em>finite
fields</em>. While this may sound daunting, the basic ideas can be easily
understood.</p>
<p>To start, think of an (n+1)-bit message as being represented by an <em>n</em>
degree polynomial, that is, a polynomial whose highest-order term is</p>
<div class="math notranslate nohighlight">
\[x^{n}\]</div>
<p>. The message is represented by a polynomial by using the value of each
bit in the message as the coefficient for each term in the polynomial,
starting with the most significant bit to represent the highest-order
term. For example, an 8-bit message consisting of the bits 10011010
corresponds to the polynomial</p>
<div class="math notranslate nohighlight">
\[M(x) = (1 \times x^7) + (0 \times x^6) + (0 \times x^5) + (1 \times
x^4 )+ (1 \times x^3) + (0 \times x^2) + (1 \times x^1) + (0 \times x^0)\]</div>
<div class="math notranslate nohighlight">
\[M(x) = x^7 + x^4 + x^3 + x^1\]</div>
<p>We can thus think of a sender and a receiver as exchanging polynomials
with each other.</p>
<p>For the purposes of calculating a CRC, a sender and receiver have to
agree on a <em>divisor</em> polynomial, <em>C(x)</em>. <em>C(x)</em> is a polynomial of
degree <em>k</em>. For example, suppose</p>
<div class="math notranslate nohighlight">
\[C(x) = x^3 + x^2 + 1\]</div>
<p>. In this case,</p>
<div class="math notranslate nohighlight">
\[k=3\]</div>
<p>. The answer to the question “Where did <em>C(x)</em> come from?” is, in most
practical cases, “You look it up in a book.” In fact, the choice of
<em>C(x)</em> has a significant impact on what types of errors can be reliably
detected, as we discuss below. There are a handful of divisor
polynomials that are very good choices for various environments, and the
exact choice is normally made as part of the protocol design. For
example, the Ethernet standard uses a well-known polynomial of
degree&nbsp;32.</p>
<p>When a sender wishes to transmit a message</p>
<div class="math notranslate nohighlight">
\[M(x)\]</div>
<p>that is n+1&nbsp;bits long, what is actually sent is the (n+1)-bit message
plus <em>k</em> bits. We call the complete transmitted message, including the
redundant bits, <em>P(x)</em>. What we are going to do is contrive to make the
polynomial representing <em>P(x)</em> exactly divisible by <em>C(x)</em>; we explain
how this is achieved below. If <em>P(x)</em> is transmitted over a link and
there are no errors introduced during transmission, then the receiver
should be able to divide <em>P(x)</em> by <em>C(x)</em> exactly, leaving a remainder
of zero. On the other hand, if some error is introduced into <em>P(x)</em>
during transmission, then in all likelihood the received polynomial will
no longer be exactly divisible by <em>C(x)</em>, and thus the receiver will
obtain a nonzero remainder implying that an error has occurred.</p>
<p>It will help to understand the following if you know a little about
polynomial arithmetic; it is just slightly different from normal integer
arithmetic. We are dealing with a special class of polynomial arithmetic
here, where coefficients may be only one or zero, and operations on the
coefficients are performed using modulo&nbsp;2 arithmetic. This is referred
to as “polynomial arithmetic modulo&nbsp;2.” Since this is a networking book,
not a mathematics text, let’s focus on the key properties of this type
of arithmetic for our purposes (which we ask you to accept on faith):</p>
<ul>
<li><p class="first">Any polynomial</p>
<div class="math notranslate nohighlight">
\[B(x)\]</div>
<p>can be divided by a divisor polynomial <em>C(x)</em> if</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}B(x)\\is of higher degree than *C(x)*.\end{aligned}\end{align} \]</div>
</li>
<li><p class="first">Any polynomial</p>
<div class="math notranslate nohighlight">
\[B(x)\]</div>
<p>can be divided once by a divisor polynomial <em>C(x)</em> if</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}B(x)\\is of the same degree as *C(x)*.\end{aligned}\end{align} \]</div>
</li>
<li><p class="first">The remainder obtained when</p>
<div class="math notranslate nohighlight">
\[B(x)\]</div>
<p>is divided by <em>C(x)</em> is obtained by performing the exclusive OR
(XOR) operation on each pair of matching coefficients.</p>
</li>
</ul>
<p>For example, the polynomial</p>
<div class="math notranslate nohighlight">
\[x^3 + 1\]</div>
<p>can be divided by</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x^3 + x^2 + 1\\(because they are both of degree 3) and the remainder would be\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}  0 \times x^3 + 1 \times x^2 + 0 \times x^1 + 0
  \times x^0 = x^2\\(obtained by XORing the coefficients of each term). In terms of\end{aligned}\end{align} \]</div>
<p>messages, we could say that 1001 can be divided by 1101 and leaves a
remainder of 0100. You should be able to see that the remainder is just
the bitwise exclusive OR of the two messages.</p>
<p>Now that we know the basic rules for dividing polynomials, we are able
to do long division, which is necessary to deal with longer messages. An
example appears below.</p>
<p>Recall that we wanted to create a polynomial for transmission that is
derived from the original message</p>
<div class="math notranslate nohighlight">
\[M(x)\]</div>
<p>, is <em>k</em>&nbsp;bits longer than</p>
<div class="math notranslate nohighlight">
\[M(x)\]</div>
<p>, and is exactly divisible by <em>C(x)</em>. We can do this in the following
way:</p>
<ol class="arabic">
<li><p class="first">Multiply</p>
<div class="math notranslate nohighlight">
\[M(x)\]</div>
<p>by</p>
<div class="math notranslate nohighlight">
\[x^{k}\]</div>
<p>; that is, add <em>k</em> zeros at the end of the message. Call this
zero-extended message</p>
<div class="math notranslate nohighlight">
\[T(x)\]</div>
<p>.</p>
</li>
<li><p class="first">Divide</p>
<div class="math notranslate nohighlight">
\[T(x)\]</div>
<p>by <em>C(x)</em> and find the remainder.</p>
</li>
<li><p class="first">Subtract the remainder from</p>
<div class="math notranslate nohighlight">
\[T(x)\]</div>
<p>.</p>
</li>
</ol>
<p>It should be obvious that what is left at this point is a message that
is exactly divisible by <em>C(x)</em>. We may also note that the resulting
message consists of</p>
<div class="math notranslate nohighlight">
\[M(x)\]</div>
<p>followed by the remainder obtained in step&nbsp;2, because when we
subtracted the remainder (which can be no more than <em>k</em>&nbsp;bits long), we
were just XORing it with the <em>k</em> zeros added in step&nbsp;1. This part will
become clearer with an example.</p>
<p>Consider the message</p>
<div class="math notranslate nohighlight">
\[x^7 + x^4 + x^3 + x^1\]</div>
<p>, or 10011010. We begin by multiplying by</p>
<div class="math notranslate nohighlight">
\[x^3\]</div>
<p>, since our divisor polynomial is of degree&nbsp;3. This gives 10011010000.
We divide this by <em>C(x)</em>, which corresponds to 1101 in this case.
<a class="reference external" href="#crcalc">Figure 1</a> shows the polynomial long-division operation.
Given the rules of polynomial arithmetic described above, the
long-division operation proceeds much as it would if we were dividing
integers. Thus, in the first step of our example, we see that the
divisor 1101 divides once into the first four bits of the message
(1001), since they are of the same degree, and leaves a remainder of 100
(1101 XOR 1001). The next step is to bring down a digit from the message
polynomial until we get another polynomial with the same degree as
<em>C(x)</em>, in this case 1001. We calculate the remainder again (100) and
continue until the calculation is complete. Note that the “result” of
the long division, which appears at the top of the calculation, is not
really of much interest—it is the remainder at the end that matters.</p>
<p>You can see from the very bottom of <a class="reference external" href="#crcalc">Figure 1</a> that the
remainder of the example calculation is 101. So we know that 10011010000
minus 101 would be exactly divisible by <em>C(x)</em>, and this is what we
send. The minus operation in polynomial arithmetic is the logical XOR
operation, so we actually send 10011010101. As noted above, this turns
out to be just the original message with the remainder from the long
division calculation appended to it. The recipient divides the received
polynomial by <em>C(x)</em> and, if the result is 0, concludes that there were
no errors. If the result is nonzero, it may be necessary to discard the
corrupted message; with some codes, it may be possible to <em>correct</em> a
small error (e.g., if the error affected only one bit). A code that
enables error correction is called an <em>error-correcting code</em>&nbsp;(ECC).</p>
<div class="figure" id="id1">
<img alt="fig-crcalc" src="direct/figures/f02-15-9780123850591.png%20width=400px" />
<p class="caption"><span class="caption-number">Figure 32: </span><span class="caption-text">fig-crcalc</span></p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="n">CRC</span> <span class="n">calculation</span> <span class="n">using</span> <span class="n">polynomial</span> <span class="n">long</span> <span class="n">division</span><span class="o">.</span>
</pre></div>
</div>
<p>Now we will consider the question of where the polynomial <em>C(x)</em> comes
from. Intuitively, the idea is to select this polynomial so that it is
very unlikely to divide evenly into a message that has errors introduced
into it. If the transmitted message is <em>P(x)</em>, we may think of the
introduction of errors as the addition of another polynomial <em>E(x)</em>, so
the recipient sees</p>
<div class="math notranslate nohighlight">
\[P(x) + E(x)\]</div>
<p>. The only way that an error could slip by undetected would be if the
received message could be evenly divided by <em>C(x)</em>, and since we know
that <em>P(x)</em> can be evenly divided by <em>C(x)</em>, this could only happen if
<em>E(x)</em> can be divided evenly by <em>C(x)</em>. The trick is to pick <em>C(x)</em> so
that this is very unlikely for common types of errors.</p>
<p>One common type of error is a single-bit error, which can be expressed
as</p>
<div class="math notranslate nohighlight">
\[E(x) = x^i\]</div>
<p>when it affects bit position <em>i</em>. If we select <em>C(x)</em> such that the
first and the last term (that is, the</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x^k\\and\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x^0\\terms) are nonzero, then we already have a two-term polynomial that\end{aligned}\end{align} \]</div>
<p>cannot divide evenly into the one term <em>E(x)</em>. Such a <em>C(x)</em> can,
therefore, detect all single-bit errors. In general, it is possible to
prove that the following types of errors can be detected by a <em>C(x)</em>
with the stated properties:</p>
<ul>
<li><p class="first">All single-bit errors, as long as the</p>
<div class="math notranslate nohighlight">
\[x^{k}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x^{0}\\terms have nonzero coefficients\end{aligned}\end{align} \]</div>
</li>
<li><p class="first">All double-bit errors, as long as <em>C(x)</em> has a factor with at least
three terms</p>
</li>
<li><p class="first">Any odd number of errors, as long as <em>C(x)</em> contains the factor</p>
<div class="math notranslate nohighlight">
\[(x + 1)\]</div>
</li>
</ul>
<p>We have mentioned that it is possible to use codes that not only detect
the presence of errors but also enable errors to be corrected. Since the
details of such codes require yet more complex mathematics than that
required to understand CRCs, we will not dwell on them here. However, it
is worth considering the merits of correction versus detection.</p>
<p>At first glance, it would seem that correction is always better, since
with detection we are forced to throw away the message and, in general,
ask for another copy to be transmitted. This uses up bandwidth and may
introduce latency while waiting for the retransmission. However, there
is a downside to correction, as it generally requires a greater number
of redundant bits to send an error-correcting code that is as strong
(that is, able to cope with the same range of errors) as a code that
only detects errors. Thus, while error detection requires more bits to
be sent when errors occur, error correction requires more bits to be
sent <em>all the time</em>. As a result, error correction tends to be most
useful when (1)&nbsp;errors are quite probable, as they may be, for example,
in a wireless environment, or (2)&nbsp;the cost of retransmission is too
high, for example, because of the latency involved retransmitting a
packet over a satellite link.</p>
<p>The use of error-correcting codes in networking is sometimes referred to
as <em>forward error correction</em> (FEC) because the correction of errors is
handled “in advance” by sending extra information, rather than waiting
for errors to happen and dealing with them later by retransmission. FEC
is commonly used in wireless networks such as 802.11.</p>
<ul class="simple">
<li>Any “burst” error (i.e., sequence of consecutive errored bits) for
which the length of the burst is less than <em>k</em> bits (Most burst
errors of length greater than <em>k</em> bits can also be detected.)</li>
</ul>
<p>Six versions of <em>C(x)</em> are widely used in link-level protocols. For
example, Ethernet uses CRC-32, which is defined as follows:</p>
<ul>
<li><p class="first">CRC-32 =</p>
<div class="math notranslate nohighlight">
\[x^{32} + x^{26} + x^{23} + x^{22} + x^{16} + x^{12} +
x^{11} + x^{10} + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1\]</div>
</li>
</ul>
<p>Finally, we note that the CRC algorithm, while seemingly complex, is
easily implemented in hardware using a <em>k</em>-bit shift register and XOR
gates. The number of bits in the shift register equals the degree of the
generator polynomial (<em>k</em>). <a class="reference external" href="#crc-hard">Figure 2</a> shows the hardware
that would be used for the generator</p>
<div class="math notranslate nohighlight">
\[x^3 + x^2 + 1\]</div>
<p>from our previous example. The message is shifted in from the left,
beginning with the most significant bit and ending with the string of
<em>k</em> zeros that is attached to the message, just as in the long division
example. When all the bits have been shifted in and appropriately XORed,
the register contains the remainder—that is, the CRC (most significant
bit on the right). The position of the XOR gates is determined as
follows: If the bits in the shift register are labeled 0 through</p>
<div class="math notranslate nohighlight">
\[k-1\]</div>
<p>, left to right, then put an XOR gate in front of bit <em>n</em> if there is a
term</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x^n\\in the generator polynomial. Thus, we see an XOR gate in front of\end{aligned}\end{align} \]</div>
<p>positions 0 and 2 for the generator</p>
<div class="math notranslate nohighlight">
\[x^3 + x^2 + x^0\]</div>
<p>.</p>
<div class="figure" id="id2">
<img alt="fig-crc-hard" src="direct/figures/f02-16-9780123850591.png%20width=350px" />
<p class="caption"><span class="caption-number">Figure 33: </span><span class="caption-text">fig-crc-hard</span></p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CRC</span> <span class="n">calculation</span> <span class="n">using</span> <span class="n">shift</span> <span class="n">register</span><span class="o">.</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="reliable.html" class="btn btn-neutral float-right" title="2.5 Reliable Transmission" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="framing.html" class="btn btn-neutral float-left" title="2.3 Framing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
